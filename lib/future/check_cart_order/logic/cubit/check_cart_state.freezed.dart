// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'check_cart_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CheckCartState {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is CheckCartState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState()';
  }
}

/// @nodoc
class $CheckCartStateCopyWith<$Res> {
  $CheckCartStateCopyWith(CheckCartState _, $Res Function(CheckCartState) __);
}

/// Adds pattern-matching-related methods to [CheckCartState].
extension CheckCartStatePatterns on CheckCartState {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(Success value)? success,
    TResult Function(Erorr value)? erorr,
    TResult Function(LoadingCoupon value)? loadingCoupon,
    TResult Function(SuccessCoupon value)? successCoupon,
    TResult Function(ErorrCoupon value)? erorrCoupon,
    TResult Function(SelectAdress value)? selectAdress,
    TResult Function(SelectType value)? selectType,
    TResult Function(SelectPayment value)? selectPayment,
    TResult Function(LoadingPayment value)? loadingPayment,
    TResult Function(SuccessPayment value)? uccessPayment,
    TResult Function(Erorrpayment value)? erorrpayment,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial(_that);
      case Loading() when loading != null:
        return loading(_that);
      case Success() when success != null:
        return success(_that);
      case Erorr() when erorr != null:
        return erorr(_that);
      case LoadingCoupon() when loadingCoupon != null:
        return loadingCoupon(_that);
      case SuccessCoupon() when successCoupon != null:
        return successCoupon(_that);
      case ErorrCoupon() when erorrCoupon != null:
        return erorrCoupon(_that);
      case SelectAdress() when selectAdress != null:
        return selectAdress(_that);
      case SelectType() when selectType != null:
        return selectType(_that);
      case SelectPayment() when selectPayment != null:
        return selectPayment(_that);
      case LoadingPayment() when loadingPayment != null:
        return loadingPayment(_that);
      case SuccessPayment() when uccessPayment != null:
        return uccessPayment(_that);
      case Erorrpayment() when erorrpayment != null:
        return erorrpayment(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(Success value) success,
    required TResult Function(Erorr value) erorr,
    required TResult Function(LoadingCoupon value) loadingCoupon,
    required TResult Function(SuccessCoupon value) successCoupon,
    required TResult Function(ErorrCoupon value) erorrCoupon,
    required TResult Function(SelectAdress value) selectAdress,
    required TResult Function(SelectType value) selectType,
    required TResult Function(SelectPayment value) selectPayment,
    required TResult Function(LoadingPayment value) loadingPayment,
    required TResult Function(SuccessPayment value) uccessPayment,
    required TResult Function(Erorrpayment value) erorrpayment,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial():
        return initial(_that);
      case Loading():
        return loading(_that);
      case Success():
        return success(_that);
      case Erorr():
        return erorr(_that);
      case LoadingCoupon():
        return loadingCoupon(_that);
      case SuccessCoupon():
        return successCoupon(_that);
      case ErorrCoupon():
        return erorrCoupon(_that);
      case SelectAdress():
        return selectAdress(_that);
      case SelectType():
        return selectType(_that);
      case SelectPayment():
        return selectPayment(_that);
      case LoadingPayment():
        return loadingPayment(_that);
      case SuccessPayment():
        return uccessPayment(_that);
      case Erorrpayment():
        return erorrpayment(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(Success value)? success,
    TResult? Function(Erorr value)? erorr,
    TResult? Function(LoadingCoupon value)? loadingCoupon,
    TResult? Function(SuccessCoupon value)? successCoupon,
    TResult? Function(ErorrCoupon value)? erorrCoupon,
    TResult? Function(SelectAdress value)? selectAdress,
    TResult? Function(SelectType value)? selectType,
    TResult? Function(SelectPayment value)? selectPayment,
    TResult? Function(LoadingPayment value)? loadingPayment,
    TResult? Function(SuccessPayment value)? uccessPayment,
    TResult? Function(Erorrpayment value)? erorrpayment,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial(_that);
      case Loading() when loading != null:
        return loading(_that);
      case Success() when success != null:
        return success(_that);
      case Erorr() when erorr != null:
        return erorr(_that);
      case LoadingCoupon() when loadingCoupon != null:
        return loadingCoupon(_that);
      case SuccessCoupon() when successCoupon != null:
        return successCoupon(_that);
      case ErorrCoupon() when erorrCoupon != null:
        return erorrCoupon(_that);
      case SelectAdress() when selectAdress != null:
        return selectAdress(_that);
      case SelectType() when selectType != null:
        return selectType(_that);
      case SelectPayment() when selectPayment != null:
        return selectPayment(_that);
      case LoadingPayment() when loadingPayment != null:
        return loadingPayment(_that);
      case SuccessPayment() when uccessPayment != null:
        return uccessPayment(_that);
      case Erorrpayment() when erorrpayment != null:
        return erorrpayment(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String erorr)? erorr,
    TResult Function()? loadingCoupon,
    TResult Function(CouponResponse coupon)? successCoupon,
    TResult Function(String erorr)? erorrCoupon,
    TResult Function()? selectAdress,
    TResult Function()? selectType,
    TResult Function()? selectPayment,
    TResult Function()? loadingPayment,
    TResult Function()? uccessPayment,
    TResult Function(String erorr)? erorrpayment,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial();
      case Loading() when loading != null:
        return loading();
      case Success() when success != null:
        return success();
      case Erorr() when erorr != null:
        return erorr(_that.erorr);
      case LoadingCoupon() when loadingCoupon != null:
        return loadingCoupon();
      case SuccessCoupon() when successCoupon != null:
        return successCoupon(_that.coupon);
      case ErorrCoupon() when erorrCoupon != null:
        return erorrCoupon(_that.erorr);
      case SelectAdress() when selectAdress != null:
        return selectAdress();
      case SelectType() when selectType != null:
        return selectType();
      case SelectPayment() when selectPayment != null:
        return selectPayment();
      case LoadingPayment() when loadingPayment != null:
        return loadingPayment();
      case SuccessPayment() when uccessPayment != null:
        return uccessPayment();
      case Erorrpayment() when erorrpayment != null:
        return erorrpayment(_that.erorr);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String erorr) erorr,
    required TResult Function() loadingCoupon,
    required TResult Function(CouponResponse coupon) successCoupon,
    required TResult Function(String erorr) erorrCoupon,
    required TResult Function() selectAdress,
    required TResult Function() selectType,
    required TResult Function() selectPayment,
    required TResult Function() loadingPayment,
    required TResult Function() uccessPayment,
    required TResult Function(String erorr) erorrpayment,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial():
        return initial();
      case Loading():
        return loading();
      case Success():
        return success();
      case Erorr():
        return erorr(_that.erorr);
      case LoadingCoupon():
        return loadingCoupon();
      case SuccessCoupon():
        return successCoupon(_that.coupon);
      case ErorrCoupon():
        return erorrCoupon(_that.erorr);
      case SelectAdress():
        return selectAdress();
      case SelectType():
        return selectType();
      case SelectPayment():
        return selectPayment();
      case LoadingPayment():
        return loadingPayment();
      case SuccessPayment():
        return uccessPayment();
      case Erorrpayment():
        return erorrpayment(_that.erorr);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String erorr)? erorr,
    TResult? Function()? loadingCoupon,
    TResult? Function(CouponResponse coupon)? successCoupon,
    TResult? Function(String erorr)? erorrCoupon,
    TResult? Function()? selectAdress,
    TResult? Function()? selectType,
    TResult? Function()? selectPayment,
    TResult? Function()? loadingPayment,
    TResult? Function()? uccessPayment,
    TResult? Function(String erorr)? erorrpayment,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial();
      case Loading() when loading != null:
        return loading();
      case Success() when success != null:
        return success();
      case Erorr() when erorr != null:
        return erorr(_that.erorr);
      case LoadingCoupon() when loadingCoupon != null:
        return loadingCoupon();
      case SuccessCoupon() when successCoupon != null:
        return successCoupon(_that.coupon);
      case ErorrCoupon() when erorrCoupon != null:
        return erorrCoupon(_that.erorr);
      case SelectAdress() when selectAdress != null:
        return selectAdress();
      case SelectType() when selectType != null:
        return selectType();
      case SelectPayment() when selectPayment != null:
        return selectPayment();
      case LoadingPayment() when loadingPayment != null:
        return loadingPayment();
      case SuccessPayment() when uccessPayment != null:
        return uccessPayment();
      case Erorrpayment() when erorrpayment != null:
        return erorrpayment(_that.erorr);
      case _:
        return null;
    }
  }
}

/// @nodoc

class _Initial implements CheckCartState {
  const _Initial();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.initial()';
  }
}

/// @nodoc

class Loading implements CheckCartState {
  const Loading();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.loading()';
  }
}

/// @nodoc

class Success implements CheckCartState {
  const Success();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Success);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.success()';
  }
}

/// @nodoc

class Erorr implements CheckCartState {
  const Erorr({required this.erorr});

  final String erorr;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErorrCopyWith<Erorr> get copyWith =>
      _$ErorrCopyWithImpl<Erorr>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Erorr &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'CheckCartState.erorr(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErorrCopyWith<$Res>
    implements $CheckCartStateCopyWith<$Res> {
  factory $ErorrCopyWith(Erorr value, $Res Function(Erorr) _then) =
      _$ErorrCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErorrCopyWithImpl<$Res> implements $ErorrCopyWith<$Res> {
  _$ErorrCopyWithImpl(this._self, this._then);

  final Erorr _self;
  final $Res Function(Erorr) _then;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(Erorr(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class LoadingCoupon implements CheckCartState {
  const LoadingCoupon();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LoadingCoupon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.loadingCoupon()';
  }
}

/// @nodoc

class SuccessCoupon implements CheckCartState {
  const SuccessCoupon(this.coupon);

  final CouponResponse coupon;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SuccessCouponCopyWith<SuccessCoupon> get copyWith =>
      _$SuccessCouponCopyWithImpl<SuccessCoupon>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SuccessCoupon &&
            (identical(other.coupon, coupon) || other.coupon == coupon));
  }

  @override
  int get hashCode => Object.hash(runtimeType, coupon);

  @override
  String toString() {
    return 'CheckCartState.successCoupon(coupon: $coupon)';
  }
}

/// @nodoc
abstract mixin class $SuccessCouponCopyWith<$Res>
    implements $CheckCartStateCopyWith<$Res> {
  factory $SuccessCouponCopyWith(
          SuccessCoupon value, $Res Function(SuccessCoupon) _then) =
      _$SuccessCouponCopyWithImpl;
  @useResult
  $Res call({CouponResponse coupon});
}

/// @nodoc
class _$SuccessCouponCopyWithImpl<$Res>
    implements $SuccessCouponCopyWith<$Res> {
  _$SuccessCouponCopyWithImpl(this._self, this._then);

  final SuccessCoupon _self;
  final $Res Function(SuccessCoupon) _then;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? coupon = null,
  }) {
    return _then(SuccessCoupon(
      null == coupon
          ? _self.coupon
          : coupon // ignore: cast_nullable_to_non_nullable
              as CouponResponse,
    ));
  }
}

/// @nodoc

class ErorrCoupon implements CheckCartState {
  const ErorrCoupon({required this.erorr});

  final String erorr;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErorrCouponCopyWith<ErorrCoupon> get copyWith =>
      _$ErorrCouponCopyWithImpl<ErorrCoupon>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErorrCoupon &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'CheckCartState.erorrCoupon(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErorrCouponCopyWith<$Res>
    implements $CheckCartStateCopyWith<$Res> {
  factory $ErorrCouponCopyWith(
          ErorrCoupon value, $Res Function(ErorrCoupon) _then) =
      _$ErorrCouponCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErorrCouponCopyWithImpl<$Res> implements $ErorrCouponCopyWith<$Res> {
  _$ErorrCouponCopyWithImpl(this._self, this._then);

  final ErorrCoupon _self;
  final $Res Function(ErorrCoupon) _then;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(ErorrCoupon(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class SelectAdress implements CheckCartState {
  const SelectAdress();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SelectAdress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.selectAdress()';
  }
}

/// @nodoc

class SelectType implements CheckCartState {
  const SelectType();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SelectType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.selectType()';
  }
}

/// @nodoc

class SelectPayment implements CheckCartState {
  const SelectPayment();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SelectPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.selectPayment()';
  }
}

/// @nodoc

class LoadingPayment implements CheckCartState {
  const LoadingPayment();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LoadingPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.loadingPayment()';
  }
}

/// @nodoc

class SuccessPayment implements CheckCartState {
  const SuccessPayment();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SuccessPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'CheckCartState.uccessPayment()';
  }
}

/// @nodoc

class Erorrpayment implements CheckCartState {
  const Erorrpayment({required this.erorr});

  final String erorr;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErorrpaymentCopyWith<Erorrpayment> get copyWith =>
      _$ErorrpaymentCopyWithImpl<Erorrpayment>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Erorrpayment &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'CheckCartState.erorrpayment(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErorrpaymentCopyWith<$Res>
    implements $CheckCartStateCopyWith<$Res> {
  factory $ErorrpaymentCopyWith(
          Erorrpayment value, $Res Function(Erorrpayment) _then) =
      _$ErorrpaymentCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErorrpaymentCopyWithImpl<$Res> implements $ErorrpaymentCopyWith<$Res> {
  _$ErorrpaymentCopyWithImpl(this._self, this._then);

  final Erorrpayment _self;
  final $Res Function(Erorrpayment) _then;

  /// Create a copy of CheckCartState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(Erorrpayment(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on
