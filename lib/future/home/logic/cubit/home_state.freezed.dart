// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$HomeState {
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is HomeState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'HomeState()';
  }
}

/// @nodoc
class $HomeStateCopyWith<$Res> {
  $HomeStateCopyWith(HomeState _, $Res Function(HomeState) __);
}

/// Adds pattern-matching-related methods to [HomeState].
extension HomeStatePatterns on HomeState {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingHome value)? loadingHome,
    TResult Function(SuccessHome value)? successHome,
    TResult Function(ErrorHome value)? errorHome,
    TResult Function(Loadingsearch value)? loadingsearch,
    TResult Function(SuccessSearch value)? successSearch,
    TResult Function(ErrorSearch value)? errorSearch,
    TResult Function(StateBottomNavigationBar value)? stateBottomNavigationBar,
    TResult Function(LoadinggetNotification value)? loadinggetNotification,
    TResult Function(SuccessgetNotification value)? successgetNotification,
    TResult Function(ErrorgetNotification value)? errorgetNotification,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial(_that);
      case LoadingHome() when loadingHome != null:
        return loadingHome(_that);
      case SuccessHome() when successHome != null:
        return successHome(_that);
      case ErrorHome() when errorHome != null:
        return errorHome(_that);
      case Loadingsearch() when loadingsearch != null:
        return loadingsearch(_that);
      case SuccessSearch() when successSearch != null:
        return successSearch(_that);
      case ErrorSearch() when errorSearch != null:
        return errorSearch(_that);
      case StateBottomNavigationBar() when stateBottomNavigationBar != null:
        return stateBottomNavigationBar(_that);
      case LoadinggetNotification() when loadinggetNotification != null:
        return loadinggetNotification(_that);
      case SuccessgetNotification() when successgetNotification != null:
        return successgetNotification(_that);
      case ErrorgetNotification() when errorgetNotification != null:
        return errorgetNotification(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingHome value) loadingHome,
    required TResult Function(SuccessHome value) successHome,
    required TResult Function(ErrorHome value) errorHome,
    required TResult Function(Loadingsearch value) loadingsearch,
    required TResult Function(SuccessSearch value) successSearch,
    required TResult Function(ErrorSearch value) errorSearch,
    required TResult Function(StateBottomNavigationBar value)
        stateBottomNavigationBar,
    required TResult Function(LoadinggetNotification value)
        loadinggetNotification,
    required TResult Function(SuccessgetNotification value)
        successgetNotification,
    required TResult Function(ErrorgetNotification value) errorgetNotification,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial():
        return initial(_that);
      case LoadingHome():
        return loadingHome(_that);
      case SuccessHome():
        return successHome(_that);
      case ErrorHome():
        return errorHome(_that);
      case Loadingsearch():
        return loadingsearch(_that);
      case SuccessSearch():
        return successSearch(_that);
      case ErrorSearch():
        return errorSearch(_that);
      case StateBottomNavigationBar():
        return stateBottomNavigationBar(_that);
      case LoadinggetNotification():
        return loadinggetNotification(_that);
      case SuccessgetNotification():
        return successgetNotification(_that);
      case ErrorgetNotification():
        return errorgetNotification(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingHome value)? loadingHome,
    TResult? Function(SuccessHome value)? successHome,
    TResult? Function(ErrorHome value)? errorHome,
    TResult? Function(Loadingsearch value)? loadingsearch,
    TResult? Function(SuccessSearch value)? successSearch,
    TResult? Function(ErrorSearch value)? errorSearch,
    TResult? Function(StateBottomNavigationBar value)? stateBottomNavigationBar,
    TResult? Function(LoadinggetNotification value)? loadinggetNotification,
    TResult? Function(SuccessgetNotification value)? successgetNotification,
    TResult? Function(ErrorgetNotification value)? errorgetNotification,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial(_that);
      case LoadingHome() when loadingHome != null:
        return loadingHome(_that);
      case SuccessHome() when successHome != null:
        return successHome(_that);
      case ErrorHome() when errorHome != null:
        return errorHome(_that);
      case Loadingsearch() when loadingsearch != null:
        return loadingsearch(_that);
      case SuccessSearch() when successSearch != null:
        return successSearch(_that);
      case ErrorSearch() when errorSearch != null:
        return errorSearch(_that);
      case StateBottomNavigationBar() when stateBottomNavigationBar != null:
        return stateBottomNavigationBar(_that);
      case LoadinggetNotification() when loadinggetNotification != null:
        return loadinggetNotification(_that);
      case SuccessgetNotification() when successgetNotification != null:
        return successgetNotification(_that);
      case ErrorgetNotification() when errorgetNotification != null:
        return errorgetNotification(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingHome,
    TResult Function(ResponseHome responseHome)? successHome,
    TResult Function(String erorr)? errorHome,
    TResult Function()? loadingsearch,
    TResult Function(Item1view responseItems)? successSearch,
    TResult Function(String erorr)? errorSearch,
    TResult Function(int page)? stateBottomNavigationBar,
    TResult Function()? loadinggetNotification,
    TResult Function(ResponseNotification responseItems)?
        successgetNotification,
    TResult Function(String erorr)? errorgetNotification,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial();
      case LoadingHome() when loadingHome != null:
        return loadingHome();
      case SuccessHome() when successHome != null:
        return successHome(_that.responseHome);
      case ErrorHome() when errorHome != null:
        return errorHome(_that.erorr);
      case Loadingsearch() when loadingsearch != null:
        return loadingsearch();
      case SuccessSearch() when successSearch != null:
        return successSearch(_that.responseItems);
      case ErrorSearch() when errorSearch != null:
        return errorSearch(_that.erorr);
      case StateBottomNavigationBar() when stateBottomNavigationBar != null:
        return stateBottomNavigationBar(_that.page);
      case LoadinggetNotification() when loadinggetNotification != null:
        return loadinggetNotification();
      case SuccessgetNotification() when successgetNotification != null:
        return successgetNotification(_that.responseItems);
      case ErrorgetNotification() when errorgetNotification != null:
        return errorgetNotification(_that.erorr);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingHome,
    required TResult Function(ResponseHome responseHome) successHome,
    required TResult Function(String erorr) errorHome,
    required TResult Function() loadingsearch,
    required TResult Function(Item1view responseItems) successSearch,
    required TResult Function(String erorr) errorSearch,
    required TResult Function(int page) stateBottomNavigationBar,
    required TResult Function() loadinggetNotification,
    required TResult Function(ResponseNotification responseItems)
        successgetNotification,
    required TResult Function(String erorr) errorgetNotification,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial():
        return initial();
      case LoadingHome():
        return loadingHome();
      case SuccessHome():
        return successHome(_that.responseHome);
      case ErrorHome():
        return errorHome(_that.erorr);
      case Loadingsearch():
        return loadingsearch();
      case SuccessSearch():
        return successSearch(_that.responseItems);
      case ErrorSearch():
        return errorSearch(_that.erorr);
      case StateBottomNavigationBar():
        return stateBottomNavigationBar(_that.page);
      case LoadinggetNotification():
        return loadinggetNotification();
      case SuccessgetNotification():
        return successgetNotification(_that.responseItems);
      case ErrorgetNotification():
        return errorgetNotification(_that.erorr);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingHome,
    TResult? Function(ResponseHome responseHome)? successHome,
    TResult? Function(String erorr)? errorHome,
    TResult? Function()? loadingsearch,
    TResult? Function(Item1view responseItems)? successSearch,
    TResult? Function(String erorr)? errorSearch,
    TResult? Function(int page)? stateBottomNavigationBar,
    TResult? Function()? loadinggetNotification,
    TResult? Function(ResponseNotification responseItems)?
        successgetNotification,
    TResult? Function(String erorr)? errorgetNotification,
  }) {
    final _that = this;
    switch (_that) {
      case _Initial() when initial != null:
        return initial();
      case LoadingHome() when loadingHome != null:
        return loadingHome();
      case SuccessHome() when successHome != null:
        return successHome(_that.responseHome);
      case ErrorHome() when errorHome != null:
        return errorHome(_that.erorr);
      case Loadingsearch() when loadingsearch != null:
        return loadingsearch();
      case SuccessSearch() when successSearch != null:
        return successSearch(_that.responseItems);
      case ErrorSearch() when errorSearch != null:
        return errorSearch(_that.erorr);
      case StateBottomNavigationBar() when stateBottomNavigationBar != null:
        return stateBottomNavigationBar(_that.page);
      case LoadinggetNotification() when loadinggetNotification != null:
        return loadinggetNotification();
      case SuccessgetNotification() when successgetNotification != null:
        return successgetNotification(_that.responseItems);
      case ErrorgetNotification() when errorgetNotification != null:
        return errorgetNotification(_that.erorr);
      case _:
        return null;
    }
  }
}

/// @nodoc

class _Initial implements HomeState {
  const _Initial();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'HomeState.initial()';
  }
}

/// @nodoc

class LoadingHome implements HomeState {
  const LoadingHome();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LoadingHome);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'HomeState.loadingHome()';
  }
}

/// @nodoc

class SuccessHome implements HomeState {
  const SuccessHome({required this.responseHome});

  final ResponseHome responseHome;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SuccessHomeCopyWith<SuccessHome> get copyWith =>
      _$SuccessHomeCopyWithImpl<SuccessHome>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SuccessHome &&
            (identical(other.responseHome, responseHome) ||
                other.responseHome == responseHome));
  }

  @override
  int get hashCode => Object.hash(runtimeType, responseHome);

  @override
  String toString() {
    return 'HomeState.successHome(responseHome: $responseHome)';
  }
}

/// @nodoc
abstract mixin class $SuccessHomeCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $SuccessHomeCopyWith(
          SuccessHome value, $Res Function(SuccessHome) _then) =
      _$SuccessHomeCopyWithImpl;
  @useResult
  $Res call({ResponseHome responseHome});
}

/// @nodoc
class _$SuccessHomeCopyWithImpl<$Res> implements $SuccessHomeCopyWith<$Res> {
  _$SuccessHomeCopyWithImpl(this._self, this._then);

  final SuccessHome _self;
  final $Res Function(SuccessHome) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? responseHome = null,
  }) {
    return _then(SuccessHome(
      responseHome: null == responseHome
          ? _self.responseHome
          : responseHome // ignore: cast_nullable_to_non_nullable
              as ResponseHome,
    ));
  }
}

/// @nodoc

class ErrorHome implements HomeState {
  const ErrorHome({required this.erorr});

  final String erorr;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorHomeCopyWith<ErrorHome> get copyWith =>
      _$ErrorHomeCopyWithImpl<ErrorHome>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorHome &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'HomeState.errorHome(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErrorHomeCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $ErrorHomeCopyWith(ErrorHome value, $Res Function(ErrorHome) _then) =
      _$ErrorHomeCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErrorHomeCopyWithImpl<$Res> implements $ErrorHomeCopyWith<$Res> {
  _$ErrorHomeCopyWithImpl(this._self, this._then);

  final ErrorHome _self;
  final $Res Function(ErrorHome) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(ErrorHome(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class Loadingsearch implements HomeState {
  const Loadingsearch();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Loadingsearch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'HomeState.loadingsearch()';
  }
}

/// @nodoc

class SuccessSearch implements HomeState {
  const SuccessSearch({required this.responseItems});

  final Item1view responseItems;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SuccessSearchCopyWith<SuccessSearch> get copyWith =>
      _$SuccessSearchCopyWithImpl<SuccessSearch>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SuccessSearch &&
            (identical(other.responseItems, responseItems) ||
                other.responseItems == responseItems));
  }

  @override
  int get hashCode => Object.hash(runtimeType, responseItems);

  @override
  String toString() {
    return 'HomeState.successSearch(responseItems: $responseItems)';
  }
}

/// @nodoc
abstract mixin class $SuccessSearchCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $SuccessSearchCopyWith(
          SuccessSearch value, $Res Function(SuccessSearch) _then) =
      _$SuccessSearchCopyWithImpl;
  @useResult
  $Res call({Item1view responseItems});
}

/// @nodoc
class _$SuccessSearchCopyWithImpl<$Res>
    implements $SuccessSearchCopyWith<$Res> {
  _$SuccessSearchCopyWithImpl(this._self, this._then);

  final SuccessSearch _self;
  final $Res Function(SuccessSearch) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? responseItems = null,
  }) {
    return _then(SuccessSearch(
      responseItems: null == responseItems
          ? _self.responseItems
          : responseItems // ignore: cast_nullable_to_non_nullable
              as Item1view,
    ));
  }
}

/// @nodoc

class ErrorSearch implements HomeState {
  const ErrorSearch({required this.erorr});

  final String erorr;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorSearchCopyWith<ErrorSearch> get copyWith =>
      _$ErrorSearchCopyWithImpl<ErrorSearch>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorSearch &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'HomeState.errorSearch(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErrorSearchCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $ErrorSearchCopyWith(
          ErrorSearch value, $Res Function(ErrorSearch) _then) =
      _$ErrorSearchCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErrorSearchCopyWithImpl<$Res> implements $ErrorSearchCopyWith<$Res> {
  _$ErrorSearchCopyWithImpl(this._self, this._then);

  final ErrorSearch _self;
  final $Res Function(ErrorSearch) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(ErrorSearch(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class StateBottomNavigationBar implements HomeState {
  const StateBottomNavigationBar({required this.page});

  final int page;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StateBottomNavigationBarCopyWith<StateBottomNavigationBar> get copyWith =>
      _$StateBottomNavigationBarCopyWithImpl<StateBottomNavigationBar>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StateBottomNavigationBar &&
            (identical(other.page, page) || other.page == page));
  }

  @override
  int get hashCode => Object.hash(runtimeType, page);

  @override
  String toString() {
    return 'HomeState.stateBottomNavigationBar(page: $page)';
  }
}

/// @nodoc
abstract mixin class $StateBottomNavigationBarCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $StateBottomNavigationBarCopyWith(StateBottomNavigationBar value,
          $Res Function(StateBottomNavigationBar) _then) =
      _$StateBottomNavigationBarCopyWithImpl;
  @useResult
  $Res call({int page});
}

/// @nodoc
class _$StateBottomNavigationBarCopyWithImpl<$Res>
    implements $StateBottomNavigationBarCopyWith<$Res> {
  _$StateBottomNavigationBarCopyWithImpl(this._self, this._then);

  final StateBottomNavigationBar _self;
  final $Res Function(StateBottomNavigationBar) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? page = null,
  }) {
    return _then(StateBottomNavigationBar(
      page: null == page
          ? _self.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class LoadinggetNotification implements HomeState {
  const LoadinggetNotification();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LoadinggetNotification);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString() {
    return 'HomeState.loadinggetNotification()';
  }
}

/// @nodoc

class SuccessgetNotification implements HomeState {
  const SuccessgetNotification({required this.responseItems});

  final ResponseNotification responseItems;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SuccessgetNotificationCopyWith<SuccessgetNotification> get copyWith =>
      _$SuccessgetNotificationCopyWithImpl<SuccessgetNotification>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SuccessgetNotification &&
            (identical(other.responseItems, responseItems) ||
                other.responseItems == responseItems));
  }

  @override
  int get hashCode => Object.hash(runtimeType, responseItems);

  @override
  String toString() {
    return 'HomeState.successgetNotification(responseItems: $responseItems)';
  }
}

/// @nodoc
abstract mixin class $SuccessgetNotificationCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $SuccessgetNotificationCopyWith(SuccessgetNotification value,
          $Res Function(SuccessgetNotification) _then) =
      _$SuccessgetNotificationCopyWithImpl;
  @useResult
  $Res call({ResponseNotification responseItems});
}

/// @nodoc
class _$SuccessgetNotificationCopyWithImpl<$Res>
    implements $SuccessgetNotificationCopyWith<$Res> {
  _$SuccessgetNotificationCopyWithImpl(this._self, this._then);

  final SuccessgetNotification _self;
  final $Res Function(SuccessgetNotification) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? responseItems = null,
  }) {
    return _then(SuccessgetNotification(
      responseItems: null == responseItems
          ? _self.responseItems
          : responseItems // ignore: cast_nullable_to_non_nullable
              as ResponseNotification,
    ));
  }
}

/// @nodoc

class ErrorgetNotification implements HomeState {
  const ErrorgetNotification({required this.erorr});

  final String erorr;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorgetNotificationCopyWith<ErrorgetNotification> get copyWith =>
      _$ErrorgetNotificationCopyWithImpl<ErrorgetNotification>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorgetNotification &&
            (identical(other.erorr, erorr) || other.erorr == erorr));
  }

  @override
  int get hashCode => Object.hash(runtimeType, erorr);

  @override
  String toString() {
    return 'HomeState.errorgetNotification(erorr: $erorr)';
  }
}

/// @nodoc
abstract mixin class $ErrorgetNotificationCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory $ErrorgetNotificationCopyWith(ErrorgetNotification value,
          $Res Function(ErrorgetNotification) _then) =
      _$ErrorgetNotificationCopyWithImpl;
  @useResult
  $Res call({String erorr});
}

/// @nodoc
class _$ErrorgetNotificationCopyWithImpl<$Res>
    implements $ErrorgetNotificationCopyWith<$Res> {
  _$ErrorgetNotificationCopyWithImpl(this._self, this._then);

  final ErrorgetNotification _self;
  final $Res Function(ErrorgetNotification) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? erorr = null,
  }) {
    return _then(ErrorgetNotification(
      erorr: null == erorr
          ? _self.erorr
          : erorr // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on
